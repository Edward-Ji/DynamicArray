<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dynamic Array: darray.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Dynamic Array
   </div>
   <div id="projectbrief">Dynamic array of void pointers with automatic                            memory free in C language</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">darray.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Dynamic array of void pointers with automatic memory free.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
</div>
<p><a href="darray_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac25bca5621b5594603e7decb66192a8c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#ac25bca5621b5594603e7decb66192a8c">consumer</a>) (void *item_ptr)</td></tr>
<tr class="memdesc:ac25bca5621b5594603e7decb66192a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The consumer function pointer type definition.  <a href="darray_8h.html#ac25bca5621b5594603e7decb66192a8c">More...</a><br /></td></tr>
<tr class="separator:ac25bca5621b5594603e7decb66192a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f027a0a2ec1540d573eb6bdddf7544"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a81f027a0a2ec1540d573eb6bdddf7544">aggregate</a>) (const void *item_ptr, void *resp)</td></tr>
<tr class="memdesc:a81f027a0a2ec1540d573eb6bdddf7544"><td class="mdescLeft">&#160;</td><td class="mdescRight">The aggregate function pointer type definition.  <a href="darray_8h.html#a81f027a0a2ec1540d573eb6bdddf7544">More...</a><br /></td></tr>
<tr class="separator:a81f027a0a2ec1540d573eb6bdddf7544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96696ef6479dff70ef363a390131f6cd"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a96696ef6479dff70ef363a390131f6cd">comparator</a>) (const void *item_ptr1, const void *item_ptr2)</td></tr>
<tr class="memdesc:a96696ef6479dff70ef363a390131f6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The comparator function pointer type definition.  <a href="darray_8h.html#a96696ef6479dff70ef363a390131f6cd">More...</a><br /></td></tr>
<tr class="separator:a96696ef6479dff70ef363a390131f6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145514e476a2b1ef91c1a0d199cee1ea"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a145514e476a2b1ef91c1a0d199cee1ea">unary</a>) (const void *item_ptr)</td></tr>
<tr class="memdesc:a145514e476a2b1ef91c1a0d199cee1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unary function pointer type definition.  <a href="darray_8h.html#a145514e476a2b1ef91c1a0d199cee1ea">More...</a><br /></td></tr>
<tr class="separator:a145514e476a2b1ef91c1a0d199cee1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0258059e3991286101c8370d42696cf4"><td class="memItemLeft" align="right" valign="top"><a id="a0258059e3991286101c8370d42696cf4" name="a0258059e3991286101c8370d42696cf4"></a>
typedef struct <a class="el" href="structdarray.html">darray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>darray</b></td></tr>
<tr class="memdesc:a0258059e3991286101c8370d42696cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a dynamic array. <br /></td></tr>
<tr class="separator:a0258059e3991286101c8370d42696cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a99021a15faa0456754015bb28a601f4c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4c">darray_error</a> { <br />
&#160;&#160;<a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4ca9350552c3a9068e8f823422daa955154">DARRAY_ERESET</a> = 0
, <a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4ca1b72648c4e02a5a619b14a47a4808f7b">DARRAY_EALLOC</a>
, <a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4ca2b76a038b976f43caa075544d1cbce2b">DARRAY_ENULLS</a>
, <a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4cae13bec232e386bcf5e1c6fdf49d2c908">DARRAY_EINDEX</a>
, <br />
&#160;&#160;<a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4caff8d5ebbe2ae18eaa3bc825e5abdc3ce">DARRAY_ENOTIN</a>
<br />
 }</td></tr>
<tr class="separator:a99021a15faa0456754015bb28a601f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae92263a7c5d51b6c3172991cd8d958bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdarray.html">darray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#ae92263a7c5d51b6c3172991cd8d958bb">new_darray</a> (<a class="el" href="darray_8h.html#ac25bca5621b5594603e7decb66192a8c">consumer</a> item_free)</td></tr>
<tr class="memdesc:ae92263a7c5d51b6c3172991cd8d958bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new dynamic array of void pointers.  <a href="darray_8h.html#ae92263a7c5d51b6c3172991cd8d958bb">More...</a><br /></td></tr>
<tr class="separator:ae92263a7c5d51b6c3172991cd8d958bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa5ccf5ffc71da3bd5ae39e34aa2848"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a2aa5ccf5ffc71da3bd5ae39e34aa2848">darray_set_item_free</a> (<a class="el" href="structdarray.html">darray</a> *array, <a class="el" href="darray_8h.html#ac25bca5621b5594603e7decb66192a8c">consumer</a> item_free)</td></tr>
<tr class="memdesc:a2aa5ccf5ffc71da3bd5ae39e34aa2848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the free function.  <a href="darray_8h.html#a2aa5ccf5ffc71da3bd5ae39e34aa2848">More...</a><br /></td></tr>
<tr class="separator:a2aa5ccf5ffc71da3bd5ae39e34aa2848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7131c23d25104eadd550a0593de83803"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a7131c23d25104eadd550a0593de83803">darray_len</a> (<a class="el" href="structdarray.html">darray</a> *array)</td></tr>
<tr class="memdesc:a7131c23d25104eadd550a0593de83803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the length of the array.  <a href="darray_8h.html#a7131c23d25104eadd550a0593de83803">More...</a><br /></td></tr>
<tr class="separator:a7131c23d25104eadd550a0593de83803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fad49e7cd9517304e21800cda261a06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a8fad49e7cd9517304e21800cda261a06">darray_foreach</a> (<a class="el" href="structdarray.html">darray</a> *array, <a class="el" href="darray_8h.html#ac25bca5621b5594603e7decb66192a8c">consumer</a> fp)</td></tr>
<tr class="memdesc:a8fad49e7cd9517304e21800cda261a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls each item in the array with a given function.  <a href="darray_8h.html#a8fad49e7cd9517304e21800cda261a06">More...</a><br /></td></tr>
<tr class="separator:a8fad49e7cd9517304e21800cda261a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3c91bb122bce6726fcafbc78de05d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#aff3c91bb122bce6726fcafbc78de05d1">darray_aggregate</a> (<a class="el" href="structdarray.html">darray</a> *array, void *resp, <a class="el" href="darray_8h.html#a81f027a0a2ec1540d573eb6bdddf7544">aggregate</a> fp)</td></tr>
<tr class="memdesc:aff3c91bb122bce6726fcafbc78de05d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates all items into a single result.  <a href="darray_8h.html#aff3c91bb122bce6726fcafbc78de05d1">More...</a><br /></td></tr>
<tr class="separator:aff3c91bb122bce6726fcafbc78de05d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641d90a542e62e7ddbf03d0e4240c329"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a641d90a542e62e7ddbf03d0e4240c329">darray_append</a> (<a class="el" href="structdarray.html">darray</a> *array, void *item_ptr)</td></tr>
<tr class="memdesc:a641d90a542e62e7ddbf03d0e4240c329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an item to the array.  <a href="darray_8h.html#a641d90a542e62e7ddbf03d0e4240c329">More...</a><br /></td></tr>
<tr class="separator:a641d90a542e62e7ddbf03d0e4240c329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92760260d46f62fcd98a20bdeebbf10"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#ab92760260d46f62fcd98a20bdeebbf10">darray_get</a> (<a class="el" href="structdarray.html">darray</a> *array, size_t index)</td></tr>
<tr class="memdesc:ab92760260d46f62fcd98a20bdeebbf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item in an array using index.  <a href="darray_8h.html#ab92760260d46f62fcd98a20bdeebbf10">More...</a><br /></td></tr>
<tr class="separator:ab92760260d46f62fcd98a20bdeebbf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d209e96fad8acb4240b619ef4bf2f57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a2d209e96fad8acb4240b619ef4bf2f57">darray_pop</a> (<a class="el" href="structdarray.html">darray</a> *array, size_t index)</td></tr>
<tr class="memdesc:a2d209e96fad8acb4240b619ef4bf2f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops an item at a given index.  <a href="darray_8h.html#a2d209e96fad8acb4240b619ef4bf2f57">More...</a><br /></td></tr>
<tr class="separator:a2d209e96fad8acb4240b619ef4bf2f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c92368130dd3e2474207c2a00551b19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a4c92368130dd3e2474207c2a00551b19">darray_pop_range</a> (<a class="el" href="structdarray.html">darray</a> *array, size_t start, size_t end)</td></tr>
<tr class="memdesc:a4c92368130dd3e2474207c2a00551b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops items at a given index range.  <a href="darray_8h.html#a4c92368130dd3e2474207c2a00551b19">More...</a><br /></td></tr>
<tr class="separator:a4c92368130dd3e2474207c2a00551b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38827e9b623d20adf5bb7c8503bfd243"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a38827e9b623d20adf5bb7c8503bfd243">darray_insert</a> (<a class="el" href="structdarray.html">darray</a> *array, size_t index, void *item_ptr)</td></tr>
<tr class="memdesc:a38827e9b623d20adf5bb7c8503bfd243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at a given index.  <a href="darray_8h.html#a38827e9b623d20adf5bb7c8503bfd243">More...</a><br /></td></tr>
<tr class="separator:a38827e9b623d20adf5bb7c8503bfd243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36523088077ece061b9406bda9993a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#ae36523088077ece061b9406bda9993a4">darray_search</a> (<a class="el" href="structdarray.html">darray</a> *array, void *item_ptr, <a class="el" href="darray_8h.html#a96696ef6479dff70ef363a390131f6cd">comparator</a> fp, size_t *idx_ptr)</td></tr>
<tr class="memdesc:ae36523088077ece061b9406bda9993a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an item in an array that compares equal to anther object.  <a href="darray_8h.html#ae36523088077ece061b9406bda9993a4">More...</a><br /></td></tr>
<tr class="separator:ae36523088077ece061b9406bda9993a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d24a7df213a684a06a2fa8a07bfbb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#ab7d24a7df213a684a06a2fa8a07bfbb6">darray_extend</a> (<a class="el" href="structdarray.html">darray</a> *array1, <a class="el" href="structdarray.html">darray</a> *array2)</td></tr>
<tr class="memdesc:ab7d24a7df213a684a06a2fa8a07bfbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends another array to the end of a given array.  <a href="darray_8h.html#ab7d24a7df213a684a06a2fa8a07bfbb6">More...</a><br /></td></tr>
<tr class="separator:ab7d24a7df213a684a06a2fa8a07bfbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa05c30ef917ceca3824fdc09eec036"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#aefa05c30ef917ceca3824fdc09eec036">darray_extend_at</a> (<a class="el" href="structdarray.html">darray</a> *array1, size_t index, <a class="el" href="structdarray.html">darray</a> *array2)</td></tr>
<tr class="memdesc:aefa05c30ef917ceca3824fdc09eec036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends another array at a given index in a given array.  <a href="darray_8h.html#aefa05c30ef917ceca3824fdc09eec036">More...</a><br /></td></tr>
<tr class="separator:aefa05c30ef917ceca3824fdc09eec036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40b70e253f204d2c8ae602bf6dd66eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#ad40b70e253f204d2c8ae602bf6dd66eb">darray_reverse</a> (<a class="el" href="structdarray.html">darray</a> *array)</td></tr>
<tr class="memdesc:ad40b70e253f204d2c8ae602bf6dd66eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a given array.  <a href="darray_8h.html#ad40b70e253f204d2c8ae602bf6dd66eb">More...</a><br /></td></tr>
<tr class="separator:ad40b70e253f204d2c8ae602bf6dd66eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed50f26758530adf2838ce77e9caa45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a9ed50f26758530adf2838ce77e9caa45">darray_unique</a> (<a class="el" href="structdarray.html">darray</a> *array, <a class="el" href="darray_8h.html#a96696ef6479dff70ef363a390131f6cd">comparator</a> fp)</td></tr>
<tr class="memdesc:a9ed50f26758530adf2838ce77e9caa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters out repeated adjacent items.  <a href="darray_8h.html#a9ed50f26758530adf2838ce77e9caa45">More...</a><br /></td></tr>
<tr class="separator:a9ed50f26758530adf2838ce77e9caa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9f699ede2f4de86d747678c9b5f774"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#abc9f699ede2f4de86d747678c9b5f774">darray_sort</a> (<a class="el" href="structdarray.html">darray</a> *array, <a class="el" href="darray_8h.html#a96696ef6479dff70ef363a390131f6cd">comparator</a> fp)</td></tr>
<tr class="memdesc:abc9f699ede2f4de86d747678c9b5f774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a given array.  <a href="darray_8h.html#abc9f699ede2f4de86d747678c9b5f774">More...</a><br /></td></tr>
<tr class="separator:abc9f699ede2f4de86d747678c9b5f774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cebb781d6cc003cfde77a1c8c919e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdarray.html">darray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a8cebb781d6cc003cfde77a1c8c919e51">darray_clone</a> (<a class="el" href="structdarray.html">darray</a> *array, <a class="el" href="darray_8h.html#a145514e476a2b1ef91c1a0d199cee1ea">unary</a> fp)</td></tr>
<tr class="memdesc:a8cebb781d6cc003cfde77a1c8c919e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a clone of a given array.  <a href="darray_8h.html#a8cebb781d6cc003cfde77a1c8c919e51">More...</a><br /></td></tr>
<tr class="separator:a8cebb781d6cc003cfde77a1c8c919e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f2cb8c11fdf3c701a167c3906d41ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a31f2cb8c11fdf3c701a167c3906d41ca">darray_clear</a> (<a class="el" href="structdarray.html">darray</a> *array)</td></tr>
<tr class="memdesc:a31f2cb8c11fdf3c701a167c3906d41ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all items from a given array.  <a href="darray_8h.html#a31f2cb8c11fdf3c701a167c3906d41ca">More...</a><br /></td></tr>
<tr class="separator:a31f2cb8c11fdf3c701a167c3906d41ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af915a40dd74bb39c0e916e933fa4d2d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#af915a40dd74bb39c0e916e933fa4d2d0">del_darray</a> (<a class="el" href="structdarray.html">darray</a> *array)</td></tr>
<tr class="memdesc:af915a40dd74bb39c0e916e933fa4d2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates a given array.  <a href="darray_8h.html#af915a40dd74bb39c0e916e933fa4d2d0">More...</a><br /></td></tr>
<tr class="separator:af915a40dd74bb39c0e916e933fa4d2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbf2da53803031e7b3f4e2cc52bfb92"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a6fbf2da53803031e7b3f4e2cc52bfb92">darray_strerr</a> ()</td></tr>
<tr class="memdesc:a6fbf2da53803031e7b3f4e2cc52bfb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a string that describes the error number.  <a href="darray_8h.html#a6fbf2da53803031e7b3f4e2cc52bfb92">More...</a><br /></td></tr>
<tr class="separator:a6fbf2da53803031e7b3f4e2cc52bfb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4bec6e6a0b3ae1a263b06e7a8e2a27d5"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a4bec6e6a0b3ae1a263b06e7a8e2a27d5">sizeof_darray</a></td></tr>
<tr class="memdesc:a4bec6e6a0b3ae1a263b06e7a8e2a27d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the dynamic array structure.  <a href="darray_8h.html#a4bec6e6a0b3ae1a263b06e7a8e2a27d5">More...</a><br /></td></tr>
<tr class="separator:a4bec6e6a0b3ae1a263b06e7a8e2a27d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106a97da7e5130af90502e7f534bc9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4c">darray_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="darray_8h.html#a106a97da7e5130af90502e7f534bc9a9">darray_errno</a></td></tr>
<tr class="memdesc:a106a97da7e5130af90502e7f534bc9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error number.  <a href="darray_8h.html#a106a97da7e5130af90502e7f534bc9a9">More...</a><br /></td></tr>
<tr class="separator:a106a97da7e5130af90502e7f534bc9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Dynamic array of void pointers with automatic memory free. </p>
<dl class="section author"><dt>Author</dt><dd>Edward Ji </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21 Jun 2022 </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac25bca5621b5594603e7decb66192a8c" name="ac25bca5621b5594603e7decb66192a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25bca5621b5594603e7decb66192a8c">&#9670;&nbsp;</a></span>consumer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* consumer) (void *item_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The consumer function pointer type definition. </p>
<p >A function of this type should take in a pointer to some object and perform some operation on that object. The function should not return anything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_ptr</td><td>Pointer to an object in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Typically used with <code><a class="el" href="darray_8h.html#a8fad49e7cd9517304e21800cda261a06" title="Calls each item in the array with a given function.">darray_foreach</a></code>.</dd></dl>
<p>An example of a consumer function pointer is a function that prints the contents at some given pointer: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> print_int(<span class="keywordtype">void</span> *p) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;%d&quot;</span>, *((<span class="keywordtype">int</span> *) p));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a81f027a0a2ec1540d573eb6bdddf7544" name="a81f027a0a2ec1540d573eb6bdddf7544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f027a0a2ec1540d573eb6bdddf7544">&#9670;&nbsp;</a></span>aggregate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* aggregate) (const void *item_ptr, void *resp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The aggregate function pointer type definition. </p>
<p >A function of this type should take in a pointer to some object and modifies the result given by the second pointer. The function should not return anything or modify the first object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_ptr</td><td>A pointer to some object. </td></tr>
    <tr><td class="paramname">resp</td><td>A pointer to the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Typically used with <code><a class="el" href="darray_8h.html#aff3c91bb122bce6726fcafbc78de05d1" title="Aggregates all items into a single result.">darray_aggregate</a></code>.</dd></dl>
<p>An example of an aggregate function pointer is a function that takes in a pointer to an integer and adds that integer to a result object at the second pointer. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> int_sum(<span class="keywordtype">void</span> *item_ptr, <span class="keywordtype">void</span> *resp) {</div>
<div class="line">    *((<span class="keywordtype">long</span> <span class="keywordtype">long</span> *) resp) += *((<span class="keywordtype">int</span> *) item_ptr);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a96696ef6479dff70ef363a390131f6cd" name="a96696ef6479dff70ef363a390131f6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96696ef6479dff70ef363a390131f6cd">&#9670;&nbsp;</a></span>comparator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* comparator) (const void *item_ptr1, const void *item_ptr2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The comparator function pointer type definition. </p>
<p >A function of this type should take in two pointers to objects and compares them. It should modify neither object nor should it return anything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_ptr1</td><td>A pointer to some object. </td></tr>
    <tr><td class="paramname">item_ptr2</td><td>A pointer to some object to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>A negative number if the first object is smaller;</li>
<li>Zero if they are equal; or</li>
<li>A positive number if the first object is bigger.</li>
</ul>
</dd></dl>
<p>An example of a comparator function pointer is a function that takes in two pointers to integers and compares them as per the rules above: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> int_cmp(<span class="keywordtype">void</span> *p1, <span class="keywordtype">void</span> *p2) {</div>
<div class="line">    <span class="keywordtype">int</span> x = *((<span class="keywordtype">int</span> *) p1);</div>
<div class="line">    <span class="keywordtype">int</span> y = *((<span class="keywordtype">int</span> *) p2);</div>
<div class="line">    <span class="keywordflow">return</span> (x &gt; y) - (x &lt; y);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The two pointers do not necessarily point to the same type. For example, given a structure with a field <code>name</code> of type <code>char[]</code>. You can write a comparator that compares this field against some string. The <code>has_name</code> function is a valid comparator: <div class="fragment"><div class="line"><span class="keyword">struct </span>person {</div>
<div class="line">    <span class="keywordtype">char</span> name[42];</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> has_name(<span class="keyword">const</span> <span class="keyword">struct</span> person *person, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {</div>
<div class="line">    <span class="keywordflow">return</span> strcmp(person-&gt;name, name);</div>
<div class="line">}</div>
</div><!-- fragment --> This also how you would search for a person with a given name using <code>darray_search</code>. </dd></dl>

</div>
</div>
<a id="a145514e476a2b1ef91c1a0d199cee1ea" name="a145514e476a2b1ef91c1a0d199cee1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145514e476a2b1ef91c1a0d199cee1ea">&#9670;&nbsp;</a></span>unary</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void *(* unary) (const void *item_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The unary function pointer type definition. </p>
<p >A function of this type should take in a pointer to some object and return a pointer to that or some other object (e.g. a copy of the original object). It should not modify the original object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_ptr</td><td>A pointer to some object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to some other object, or the given object.</dd></dl>
<p>An example of a unary function pointer is a function that takes in the pointer and returns it. This is useful for creating a shallow copy of an array with <code>darray_clone</code>. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> *identity(<span class="keyword">const</span> <span class="keywordtype">void</span> *p) { <span class="keywordflow">return</span> p; }</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a99021a15faa0456754015bb28a601f4c" name="a99021a15faa0456754015bb28a601f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99021a15faa0456754015bb28a601f4c">&#9670;&nbsp;</a></span>darray_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4c">darray_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a99021a15faa0456754015bb28a601f4ca9350552c3a9068e8f823422daa955154" name="a99021a15faa0456754015bb28a601f4ca9350552c3a9068e8f823422daa955154"></a>DARRAY_ERESET&#160;</td><td class="fielddoc"><p >Error number not set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99021a15faa0456754015bb28a601f4ca1b72648c4e02a5a619b14a47a4808f7b" name="a99021a15faa0456754015bb28a601f4ca1b72648c4e02a5a619b14a47a4808f7b"></a>DARRAY_EALLOC&#160;</td><td class="fielddoc"><p >Fail to allocate memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99021a15faa0456754015bb28a601f4ca2b76a038b976f43caa075544d1cbce2b" name="a99021a15faa0456754015bb28a601f4ca2b76a038b976f43caa075544d1cbce2b"></a>DARRAY_ENULLS&#160;</td><td class="fielddoc"><p >Invalid <code>NULL</code> argument to function </p>
</td></tr>
<tr><td class="fieldname"><a id="a99021a15faa0456754015bb28a601f4cae13bec232e386bcf5e1c6fdf49d2c908" name="a99021a15faa0456754015bb28a601f4cae13bec232e386bcf5e1c6fdf49d2c908"></a>DARRAY_EINDEX&#160;</td><td class="fielddoc"><p >Invalid index. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99021a15faa0456754015bb28a601f4caff8d5ebbe2ae18eaa3bc825e5abdc3ce" name="a99021a15faa0456754015bb28a601f4caff8d5ebbe2ae18eaa3bc825e5abdc3ce"></a>DARRAY_ENOTIN&#160;</td><td class="fielddoc"><p >Item does not exist. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae92263a7c5d51b6c3172991cd8d958bb" name="ae92263a7c5d51b6c3172991cd8d958bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92263a7c5d51b6c3172991cd8d958bb">&#9670;&nbsp;</a></span>new_darray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdarray.html">darray</a> * new_darray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="darray_8h.html#ac25bca5621b5594603e7decb66192a8c">consumer</a>&#160;</td>
          <td class="paramname"><em>item_free</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new dynamic array of void pointers. </p>
<p >The function allocates a new dynamic array of generic pointers and returns it. It accepts a consumer function pointer that deallocates an item and its components. The free function can be <code>NULL</code> which means that the items does not need to be freed. This could be useful for creating a shallow copy (view) of the original array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_free</td><td>A pointer to a function that frees an item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new dynamic array object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>To deallocate the dynamic array, use <code><a class="el" href="darray_8h.html#af915a40dd74bb39c0e916e933fa4d2d0" title="Deallocates a given array.">del_darray</a></code>. </dd></dl>

</div>
</div>
<a id="a2aa5ccf5ffc71da3bd5ae39e34aa2848" name="a2aa5ccf5ffc71da3bd5ae39e34aa2848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa5ccf5ffc71da3bd5ae39e34aa2848">&#9670;&nbsp;</a></span>darray_set_item_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_set_item_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="darray_8h.html#ac25bca5621b5594603e7decb66192a8c">consumer</a>&#160;</td>
          <td class="paramname"><em>item_free</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the free function. </p>
<p >This function sets the function pointer that frees the item if the item pointer is removed from the array. You should rarely need to use this function, except for temporarily disabling the free behaviour of other dynamic array functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">item_free</td><td>A pointer to a function that frees an item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can temporarily disable automatic de-allocation of array items by setting <code>item_free</code> to <code>NULL</code> and back. </dd></dl>

</div>
</div>
<a id="a7131c23d25104eadd550a0593de83803" name="a7131c23d25104eadd550a0593de83803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7131c23d25104eadd550a0593de83803">&#9670;&nbsp;</a></span>darray_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t darray_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the length of the array. </p>
<p >This function returns the number of items in a given array. Returns 0 if the argument is <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items in a given array. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not set <code>darray_errno</code> even if the argument is <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="a8fad49e7cd9517304e21800cda261a06" name="a8fad49e7cd9517304e21800cda261a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fad49e7cd9517304e21800cda261a06">&#9670;&nbsp;</a></span>darray_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="darray_8h.html#ac25bca5621b5594603e7decb66192a8c">consumer</a>&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls each item in the array with a given function. </p>
<p >This function calls the given function with every object in the array sequentially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">fp</td><td>A pointer to a consumer function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="aff3c91bb122bce6726fcafbc78de05d1" name="aff3c91bb122bce6726fcafbc78de05d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3c91bb122bce6726fcafbc78de05d1">&#9670;&nbsp;</a></span>darray_aggregate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_aggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>resp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="darray_8h.html#a81f027a0a2ec1540d573eb6bdddf7544">aggregate</a>&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggregates all items into a single result. </p>
<p >This function calls the aggregation function with every item in the array as the first argument, and the result pointer as the second argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">resp</td><td>A pointer to the result object. </td></tr>
    <tr><td class="paramname">fp</td><td>A pointer to an aggregate function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>How to write an <code><a class="el" href="darray_8h.html#a81f027a0a2ec1540d573eb6bdddf7544" title="The aggregate function pointer type definition.">aggregate</a></code> function. </dd></dl>

</div>
</div>
<a id="a641d90a542e62e7ddbf03d0e4240c329" name="a641d90a542e62e7ddbf03d0e4240c329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641d90a542e62e7ddbf03d0e4240c329">&#9670;&nbsp;</a></span>darray_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>item_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends an item to the array. </p>
<p >This function appends an item to the end of an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">item_ptr</td><td>A pointer to an item to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ab92760260d46f62fcd98a20bdeebbf10" name="ab92760260d46f62fcd98a20bdeebbf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92760260d46f62fcd98a20bdeebbf10">&#9670;&nbsp;</a></span>darray_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * darray_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an item in an array using index. </p>
<p >This function attempts to return the item at a given index in the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">index</td><td>A valid index in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The item at the given index in the array if successful, <code>NULL</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function is unsuccessful if the pointer to an array is <code>NULL</code> or the index is out of range. </dd></dl>

</div>
</div>
<a id="a2d209e96fad8acb4240b619ef4bf2f57" name="a2d209e96fad8acb4240b619ef4bf2f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d209e96fad8acb4240b619ef4bf2f57">&#9670;&nbsp;</a></span>darray_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops an item at a given index. </p>
<p >This function pops the item at a given index from an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">index</td><td>A valid index in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The free function associated with the array is called if it's not <code>NULL</code>. If the function properly deallocates the item, accessing the popped object may be undefined behavior. <div class="fragment"><div class="line">arr = <a class="code hl_function" href="darray_8c.html#ae92263a7c5d51b6c3172991cd8d958bb">new_darray</a>(free);</div>
<div class="line"><span class="keywordtype">int</span> *p = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div>
<div class="line">*p = 42;</div>
<div class="line"><a class="code hl_function" href="darray_8c.html#a641d90a542e62e7ddbf03d0e4240c329">darray_append</a>(arr, p);</div>
<div class="line"><a class="code hl_function" href="darray_8c.html#a2d209e96fad8acb4240b619ef4bf2f57">darray_pop</a>(0); <span class="comment">// `free(p)` called</span></div>
<div class="line">*p = 0;        <span class="comment">// undefined behavior</span></div>
<div class="ttc" id="adarray_8c_html_a2d209e96fad8acb4240b619ef4bf2f57"><div class="ttname"><a href="darray_8c.html#a2d209e96fad8acb4240b619ef4bf2f57">darray_pop</a></div><div class="ttdeci">int darray_pop(darray *array, size_t index)</div><div class="ttdoc">Pops an item at a given index.</div><div class="ttdef"><b>Definition:</b> darray.c:154</div></div>
<div class="ttc" id="adarray_8c_html_a641d90a542e62e7ddbf03d0e4240c329"><div class="ttname"><a href="darray_8c.html#a641d90a542e62e7ddbf03d0e4240c329">darray_append</a></div><div class="ttdeci">int darray_append(darray *array, void *item_ptr)</div><div class="ttdoc">Appends an item to the array.</div><div class="ttdef"><b>Definition:</b> darray.c:124</div></div>
<div class="ttc" id="adarray_8c_html_ae92263a7c5d51b6c3172991cd8d958bb"><div class="ttname"><a href="darray_8c.html#ae92263a7c5d51b6c3172991cd8d958bb">new_darray</a></div><div class="ttdeci">darray * new_darray(consumer item_free)</div><div class="ttdoc">Creates a new dynamic array of void pointers.</div><div class="ttdef"><b>Definition:</b> darray.c:33</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4c92368130dd3e2474207c2a00551b19" name="a4c92368130dd3e2474207c2a00551b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c92368130dd3e2474207c2a00551b19">&#9670;&nbsp;</a></span>darray_pop_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_pop_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops items at a given index range. </p>
<p >This function pops the items at a given index range from the array. This includes the item at the starting index, the items between the starting index and the ending index, but <b>not</b> the item at the end index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">start</td><td>An index from which to start popping (inclusive). </td></tr>
    <tr><td class="paramname">end</td><td>An index at which to stop popping (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The free function associated with the array is called for each item if the function is not <code>NULL</code>. If the function properly deallocates the items, accessing any popped object may be undefined behavior. </dd></dl>

</div>
</div>
<a id="a38827e9b623d20adf5bb7c8503bfd243" name="a38827e9b623d20adf5bb7c8503bfd243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38827e9b623d20adf5bb7c8503bfd243">&#9670;&nbsp;</a></span>darray_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>item_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an item at a given index. </p>
<p >This function inserts an item at an given index in an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">index</td><td>A valid index to insert at. </td></tr>
    <tr><td class="paramname">item_ptr</td><td>A pointer to an item to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ae36523088077ece061b9406bda9993a4" name="ae36523088077ece061b9406bda9993a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36523088077ece061b9406bda9993a4">&#9670;&nbsp;</a></span>darray_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>item_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="darray_8h.html#a96696ef6479dff70ef363a390131f6cd">comparator</a>&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>idx_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for an item in an array that compares equal to anther object. </p>
<p >Searches for an item in the array using a given comparator and stores its index in the index pointer. The comparator is called with an array item as the first argument, and the item to compare against as the second argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">item_ptr</td><td>An object to compare against. </td></tr>
    <tr><td class="paramname">fp</td><td>A pointer to a function that compares array item against the object. </td></tr>
    <tr><td class="paramname">idx_ptr</td><td>A pointer to store the index of found item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there is a match, or 0 otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>How to write a <code><a class="el" href="darray_8h.html#a96696ef6479dff70ef363a390131f6cd" title="The comparator function pointer type definition.">comparator</a></code>.</dd></dl>
<p>For example, to find the index of <code>42</code> in some integer array: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> target = 42;</div>
<div class="line"><span class="keywordtype">size_t</span> index;</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="darray_8c.html#ae36523088077ece061b9406bda9993a4">darray_search</a>(array_pointer, &amp;42, integer_comparator, &amp;index)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;42 not in array!&quot;</span>);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line">printf(<span class="stringliteral">&quot;42 at index %zu.&quot;</span>, index);</div>
<div class="ttc" id="adarray_8c_html_ae36523088077ece061b9406bda9993a4"><div class="ttname"><a href="darray_8c.html#ae36523088077ece061b9406bda9993a4">darray_search</a></div><div class="ttdeci">int darray_search(darray *array, void *item_ptr, comparator fp, size_t *idx_ptr)</div><div class="ttdoc">Searches for an item in an array that compares equal to anther object.</div><div class="ttdef"><b>Definition:</b> darray.c:230</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab7d24a7df213a684a06a2fa8a07bfbb6" name="ab7d24a7df213a684a06a2fa8a07bfbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d24a7df213a684a06a2fa8a07bfbb6">&#9670;&nbsp;</a></span>darray_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends another array to the end of a given array. </p>
<p >In the order of their index, append each item in the second array to the end of the first one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array1</td><td>A pointer to a dynamic array to extend to. </td></tr>
    <tr><td class="paramname">array2</td><td>A pointer to another dynamic array to extend from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="aefa05c30ef917ceca3824fdc09eec036" name="aefa05c30ef917ceca3824fdc09eec036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa05c30ef917ceca3824fdc09eec036">&#9670;&nbsp;</a></span>darray_extend_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_extend_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends another array at a given index in a given array. </p>
<p >In the order of their index, insert each item in the second array at the given index of the first one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array1</td><td>A pointer to a dynamic array to extend to. </td></tr>
    <tr><td class="paramname">index</td><td>A valid index in the first array to extend at. </td></tr>
    <tr><td class="paramname">array2</td><td>A pointer to another dynamic array to extend from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ad40b70e253f204d2c8ae602bf6dd66eb" name="ad40b70e253f204d2c8ae602bf6dd66eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40b70e253f204d2c8ae602bf6dd66eb">&#9670;&nbsp;</a></span>darray_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses a given array. </p>
<p >This function reverses a given array <b>in place</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a9ed50f26758530adf2838ce77e9caa45" name="a9ed50f26758530adf2838ce77e9caa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed50f26758530adf2838ce77e9caa45">&#9670;&nbsp;</a></span>darray_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="darray_8h.html#a96696ef6479dff70ef363a390131f6cd">comparator</a>&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters out repeated adjacent items. </p>
<p >The second and succeeding copies of equal adjacent items are popped from the array. The items are considered equal if they return <code>0</code> when passed into a given comparator function. The function performs the above <b>in place</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">fp</td><td>A pointer to a function that compares two items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The behavior of this function mimics that of the Unix <code>uniq</code> utility. </dd></dl>

</div>
</div>
<a id="abc9f699ede2f4de86d747678c9b5f774" name="abc9f699ede2f4de86d747678c9b5f774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9f699ede2f4de86d747678c9b5f774">&#9670;&nbsp;</a></span>darray_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="darray_8h.html#a96696ef6479dff70ef363a390131f6cd">comparator</a>&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a given array. </p>
<p >Sorts all items in the given array <b>in place</b> using a quick sort algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">fp</td><td>A pointer to a function that compares two items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise.</dd></dl>
<p>The sorting algorithm is adopted from <a href="https://gist.github.com/adwiteeya3/f1797534506be672b591f465c3366643">Quick Sort.c</a> by adwiteeya3 on GitHub. </p>

</div>
</div>
<a id="a8cebb781d6cc003cfde77a1c8c919e51" name="a8cebb781d6cc003cfde77a1c8c919e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cebb781d6cc003cfde77a1c8c919e51">&#9670;&nbsp;</a></span>darray_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdarray.html">darray</a> * darray_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="darray_8h.html#a145514e476a2b1ef91c1a0d199cee1ea">unary</a>&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a clone of a given array. </p>
<p >This function calls the clone function on each item in the array and returns them in a new array. The new array inherits the free function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array. </td></tr>
    <tr><td class="paramname">fp</td><td>A pointer to a function that, given an item of the array, produces a clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new allocated dynamic array.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the clone function provided, this function can produce a shallow or deep copy of the given array. For example, given an array of integer, <div class="fragment"><div class="line"><span class="keywordtype">void</span> *shallow(<span class="keywordtype">void</span> *p) { <span class="keywordflow">return</span> p; }</div>
<div class="line"><span class="keywordtype">void</span> *deep(<span class="keywordtype">void</span> *p) {</div>
<div class="line">    <span class="keywordtype">int</span> *cpy = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div>
<div class="line">    *cpy = *((<span class="keywordtype">int</span> *) p);</div>
<div class="line">    <span class="keywordflow">return</span> cpy;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">integer_array = <a class="code hl_function" href="darray_8c.html#ae92263a7c5d51b6c3172991cd8d958bb">new_darray</a>(free);</div>
<div class="line"><span class="comment">// Omit: adding integer items to the array.</span></div>
<div class="line">clone1 = <a class="code hl_function" href="darray_8c.html#a8cebb781d6cc003cfde77a1c8c919e51">darray_clone</a>(integer_array, shallow); <span class="comment">// creates a shallow copy</span></div>
<div class="line"><a class="code hl_function" href="darray_8c.html#a2aa5ccf5ffc71da3bd5ae39e34aa2848">darray_set_item_free</a>(clone1, NULL);            <span class="comment">// usually required logically</span></div>
<div class="line">clone2 = <a class="code hl_function" href="darray_8c.html#a8cebb781d6cc003cfde77a1c8c919e51">darray_clone</a>(integer_array, deep);    <span class="comment">// creates a deep copy</span></div>
<div class="ttc" id="adarray_8c_html_a2aa5ccf5ffc71da3bd5ae39e34aa2848"><div class="ttname"><a href="darray_8c.html#a2aa5ccf5ffc71da3bd5ae39e34aa2848">darray_set_item_free</a></div><div class="ttdeci">int darray_set_item_free(darray *array, consumer item_free)</div><div class="ttdoc">Sets the free function.</div><div class="ttdef"><b>Definition:</b> darray.c:49</div></div>
<div class="ttc" id="adarray_8c_html_a8cebb781d6cc003cfde77a1c8c919e51"><div class="ttname"><a href="darray_8c.html#a8cebb781d6cc003cfde77a1c8c919e51">darray_clone</a></div><div class="ttdeci">darray * darray_clone(darray *array, unary fp)</div><div class="ttdoc">Returns a clone of a given array.</div><div class="ttdef"><b>Definition:</b> darray.c:376</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a31f2cb8c11fdf3c701a167c3906d41ca" name="a31f2cb8c11fdf3c701a167c3906d41ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f2cb8c11fdf3c701a167c3906d41ca">&#9670;&nbsp;</a></span>darray_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int darray_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all items from a given array. </p>
<p >This function pops all items from the array and calls the free function on each of them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array to clear. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="af915a40dd74bb39c0e916e933fa4d2d0" name="af915a40dd74bb39c0e916e933fa4d2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af915a40dd74bb39c0e916e933fa4d2d0">&#9670;&nbsp;</a></span>del_darray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int del_darray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdarray.html">darray</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates a given array. </p>
<p >This function clears all items from a given array and deallocates the dynamic array structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to a dynamic array to deallocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fbf2da53803031e7b3f4e2cc52bfb92" name="a6fbf2da53803031e7b3f4e2cc52bfb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbf2da53803031e7b3f4e2cc52bfb92">&#9670;&nbsp;</a></span>darray_strerr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * darray_strerr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a string that describes the error number. </p>
<p >This function returns a pointer to a string that describes the error number <code>darray_errno</code> if it is set. Calling the function resets the error number. If the error number is not set, the function returns a null pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a string that describes the error number. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4bec6e6a0b3ae1a263b06e7a8e2a27d5" name="a4bec6e6a0b3ae1a263b06e7a8e2a27d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bec6e6a0b3ae1a263b06e7a8e2a27d5">&#9670;&nbsp;</a></span>sizeof_darray</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t sizeof_darray</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the dynamic array structure. </p>
<p >Use this instead of <code>sizeof(darray)</code> because the dynamic array structure definition is incomplete in this header. </p>

</div>
</div>
<a id="a106a97da7e5130af90502e7f534bc9a9" name="a106a97da7e5130af90502e7f534bc9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106a97da7e5130af90502e7f534bc9a9">&#9670;&nbsp;</a></span>darray_errno</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4c">darray_error</a> darray_errno</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The error number. </p>
<p >This variable is set whenever a function fails. Most functions return 0 if unsuccessful and sets this error number.</p>
<dl class="section see"><dt>See also</dt><dd>The <code><a class="el" href="darray_8h.html#a99021a15faa0456754015bb28a601f4c">darray_error</a></code> enumerator documents all error codes. The <code>darray_str_err</code> function returns a meaningful description of the error codes. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
